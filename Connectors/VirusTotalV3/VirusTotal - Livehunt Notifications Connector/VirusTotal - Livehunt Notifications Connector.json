{
    "isUpdateAvailable": false,
    "isCustom": false,
    "isEnabled": false,
    "isRemoteConnector": false,
    "environment": "I",
    "integration": "VirusTotalV3",
    "identifier": "VirusTotal - Livehunt Notifications Connector_0104ec72-efbc-4445-bd02-d4f7c09743f0",
    "connectorDefinitionName": "VirusTotal - Livehunt Notifications Connector",
    "displayName": "VirusTotal - Livehunt Notifications Connector",
    "description": "Pull information about Livehunt notifications and related files from VirusTotal. Note: this connector requires a premium API token. Dynamic list works with \"rule_name\" parameter.",
    "runIntervalInSeconds": 10,
    "resultDataType": 0,
    "version": "1",
    "pythonVersion": 3,
    "isAllowlistSupported": false,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Environment Field Name",
            "paramValue": "",
            "description": "Describes the name of the field where the environment name is stored. If the environment field isn't found, the environment is the default environment.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Regex Pattern",
            "paramValue": ".*",
            "description": "A regex pattern to run on the value found in the \"Environment Field Name\" field. Default is .* to catch all and return the value unchanged. Used to allow the user to manipulate the environment field via regex logic. If the regex pattern is null or empty, or the environment value is null, the final environment result is the default environment.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "180",
            "description": "Timeout limit for the python process running the current script.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "API Key",
            "paramValue": "***************",
            "description": "VirusTotal API Key.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Verify SSL",
            "paramValue": "false",
            "description": "If enabled, verify the SSL certificate for the connection to the VirusTotal server is valid.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Engine Whitelist",
            "paramValue": "",
            "description": "Specify a comma-separated list of engines that should be used, when counting the \\'Engine Percentage Threshold To Fetch\\' parameter. Example: AlienVault,Kaspersky. Note: if nothing is provided, all engines from the response are counted.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Engine Percentage Threshold To Fetch",
            "paramValue": "0",
            "description": "The percentage of engines that need to mark the file as suspicious/malicious before it's being ingested. Maximum value: 100. Minimum: 0.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Hours Backwards",
            "paramValue": "1",
            "description": "Number of hours before the first connector iteration to retrieve notifications from. This parameter applies to the initial connector iteration after you enable the connector for the first time, or used as a fallback value in cases where connector's last run timestamp expires.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Notifications To Fetch",
            "paramValue": "40",
            "description": "How many notifications to process per one connector iteration. Default: 40.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Use dynamic list as a blacklist",
            "paramValue": "false",
            "description": "If enabled, dynamic lists will be used as a blacklist.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": "",
            "description": "The address of the proxy server to use.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Username",
            "paramValue": "",
            "description": "The proxy username to authenticate with.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Password",
            "paramValue": "",
            "description": "The proxy password to authenticate with.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        }
    ],
    "allowList": [],
    "integrationVersion": 37.0,
    "isScriptConnector": true,
    "script": "from SiemplifyUtils import output_handler, unix_now\nfrom SiemplifyConnectors import SiemplifyConnectorExecution\nfrom TIPCommon.extraction import extract_connector_param\nfrom TIPCommon.smp_io import read_ids, write_ids\nfrom TIPCommon.smp_time import (\n    get_last_success_time,\n    DATETIME_FORMAT,\n    save_timestamp,\n    is_approaching_timeout,\n)\nfrom TIPCommon.utils import is_overflowed\nfrom constants import (\n    CONNECTOR_NAME,\n    DEFAULT_NOTIFICATIONS_LIMIT,\n    DEFAULT_TIME_FRAME,\n    TIMESTAMP_KEY,\n)\nfrom UtilsManager import (\n    pass_whitelist_filter,\n    convert_comma_separated_to_list,\n    datetime_to_rfc3339,\n    convert_list_to_comma_string,\n)\nfrom VirusTotalManager import VirusTotalManager\nfrom SiemplifyConnectorsDataModel import AlertInfo\nimport sys\nfrom EnvironmentCommon import GetEnvironmentCommonFactory\n\n\nconnector_starting_time = unix_now()\n\n\n@output_handler\ndef main(is_test_run):\n    siemplify = SiemplifyConnectorExecution()\n    siemplify.script_name = CONNECTOR_NAME\n    processed_alerts = []\n\n    if is_test_run:\n        siemplify.LOGGER.info(\n            '***** This is an \"IDE Play Button\"\\\\\"Run Connector once\" test run ******'\n        )\n\n    siemplify.LOGGER.info(\"------------------- Main - Param Init -------------------\")\n\n    api_key = extract_connector_param(\n        siemplify, param_name=\"API Key\", is_mandatory=True\n    )\n    verify_ssl = extract_connector_param(\n        siemplify,\n        param_name=\"Verify SSL\",\n        is_mandatory=True,\n        input_type=bool,\n        print_value=True,\n    )\n    environment_field_name = extract_connector_param(\n        siemplify, param_name=\"Environment Field Name\", print_value=True\n    )\n    environment_regex_pattern = extract_connector_param(\n        siemplify, param_name=\"Environment Regex Pattern\", print_value=True\n    )\n\n    script_timeout = extract_connector_param(\n        siemplify,\n        param_name=\"PythonProcessTimeout\",\n        is_mandatory=True,\n        input_type=int,\n        print_value=True,\n    )\n    percentage_threshold = extract_connector_param(\n        siemplify,\n        param_name=\"Engine Percentage Threshold To Fetch\",\n        is_mandatory=True,\n        input_type=int,\n        print_value=True,\n    )\n    engine_whitelist_str = extract_connector_param(\n        siemplify, param_name=\"Engine Whitelist\", is_mandatory=False, print_value=True\n    )\n    hours_backwards = extract_connector_param(\n        siemplify,\n        param_name=\"Max Hours Backwards\",\n        input_type=int,\n        default_value=DEFAULT_TIME_FRAME,\n        print_value=True,\n    )\n    fetch_limit = extract_connector_param(\n        siemplify,\n        param_name=\"Max Notifications To Fetch\",\n        input_type=int,\n        default_value=DEFAULT_NOTIFICATIONS_LIMIT,\n        print_value=True,\n    )\n    whitelist_as_a_blacklist = extract_connector_param(\n        siemplify,\n        \"Use dynamic list as a blacklist\",\n        is_mandatory=True,\n        input_type=bool,\n        print_value=True,\n    )\n    device_product_field = extract_connector_param(\n        siemplify, \"DeviceProductField\", is_mandatory=True\n    )\n    engine_whitelist = convert_comma_separated_to_list(engine_whitelist_str)\n\n    try:\n        siemplify.LOGGER.info(\"------------------- Main - Started -------------------\")\n\n        if hours_backwards < 1:\n            siemplify.LOGGER.info(\n                f\"Max Hours Backwards must be greater than zero. \"\n                f\"The default value {DEFAULT_TIME_FRAME} will be used\"\n            )\n            hours_backwards = DEFAULT_TIME_FRAME\n\n        if fetch_limit < 1:\n            siemplify.LOGGER.info(\n                f\"Max Notifications To Fetch must be greater than zero. \"\n                f\"The default value {DEFAULT_NOTIFICATIONS_LIMIT} will be used\"\n            )\n            fetch_limit = DEFAULT_NOTIFICATIONS_LIMIT\n\n        if percentage_threshold > 100 or percentage_threshold < 0:\n            raise Exception(\n                \"value for the parameter 'Engine Percentage Threshold To Fetch' is \"\n                \"invalid. Please check it. The value should be in range from 0 to 100\"\n            )\n\n        # Read already existing alerts ids\n        existing_ids = read_ids(siemplify)\n        siemplify.LOGGER.info(\n            f\"Successfully loaded {len(existing_ids)} existing alerts from ids file\"\n        )\n\n        manager = VirusTotalManager(api_key=api_key, verify_ssl=verify_ssl)\n\n        last_success_time = get_last_success_time(\n            siemplify=siemplify,\n            offset_with_metric={\"hours\": hours_backwards},\n            time_format=DATETIME_FORMAT,\n        )\n\n        fetched_alerts = []\n\n        notifications = manager.get_livehunt_notifications(\n            start_timestamp=datetime_to_rfc3339(last_success_time),\n            limit=fetch_limit,\n            siemplify=siemplify,\n            existing_ids=existing_ids,\n        )\n\n        siemplify.LOGGER.info(f\"Fetched {len(notifications)} alerts\")\n\n        if is_test_run:\n            siemplify.LOGGER.info(\"This is a TEST run. Only 1 alert will be processed.\")\n            notifications = notifications[:1]\n\n        for alert in notifications:\n            try:\n                if is_approaching_timeout(connector_starting_time, script_timeout):\n                    siemplify.LOGGER.info(\n                        \"Timeout is approaching. Connector will gracefully exit\"\n                    )\n                    break\n\n                if len(processed_alerts) >= fetch_limit:\n                    # Provide slicing for the alerts amount.\n                    siemplify.LOGGER.info(\n                        \"Reached max number of alerts cycle. No more alerts will be processed in this cycle.\"\n                    )\n                    break\n\n                siemplify.LOGGER.info(f\"Started processing alert {alert.id}\")\n                alert.set_supported_engines(engine_whitelist)\n\n                if engine_whitelist and not alert.supported_engines:\n                    siemplify.LOGGER.warn(\n                        \"None of the provided engines are available and \"\n                        \"will be ignored.\"\n                    )\n                elif alert.invalid_engines:\n                    siemplify.LOGGER.warn(\n                        f\"Following engines are not available and will be ignored: \"\n                        f\"{convert_list_to_comma_string(alert.invalid_engines)}\"\n                    )\n\n                # Update existing alerts\n                existing_ids.append(alert.id)\n                fetched_alerts.append(alert)\n\n                if not pass_filters(\n                    siemplify,\n                    whitelist_as_a_blacklist,\n                    alert,\n                    \"rule_name\",\n                    percentage_threshold,\n                ):\n                    continue\n\n                alert_info = alert.get_alert_info(\n                    alert_info=AlertInfo(),\n                    environment_common=GetEnvironmentCommonFactory().create_environment_manager(\n                        siemplify, environment_field_name, environment_regex_pattern\n                    ),\n                    device_product_field=device_product_field,\n                )\n\n                if is_overflowed(siemplify, alert_info, is_test_run):\n                    siemplify.LOGGER.info(\n                        f\"{alert_info.rule_generator}-\"\n                        f\"{alert_info.ticket_id}-{alert_info.environment}\"\n                        f\"-{alert_info.device_product} \"\n                        f\"found as overflow alert. Skipping...\"\n                    )\n                    # If is overflowed we should skip\n                    continue\n\n                processed_alerts.append(alert_info)\n                siemplify.LOGGER.info(f\"Alert {alert.id} was created.\")\n\n            except Exception as e:\n                siemplify.LOGGER.error(f\"Failed to process alert {alert.id}\")\n                siemplify.LOGGER.exception(e)\n\n                if is_test_run:\n                    raise\n\n            siemplify.LOGGER.info(f\"Finished processing alert {alert.id}\")\n\n        if not is_test_run:\n            siemplify.LOGGER.info(\"Saving existing ids.\")\n            write_ids(siemplify, existing_ids)\n            save_timestamp(\n                siemplify=siemplify,\n                alerts=fetched_alerts,\n                timestamp_key=TIMESTAMP_KEY,\n                convert_timestamp_to_micro_time=True,\n            )\n\n    except Exception as e:\n        siemplify.LOGGER.error(f\"Got exception on main handler. Error: {e}\")\n        siemplify.LOGGER.exception(e)\n\n        if is_test_run:\n            raise\n\n    siemplify.LOGGER.info(f\"Created total of {len(processed_alerts)} cases\")\n    siemplify.LOGGER.info(\"------------------- Main - Finished -------------------\")\n    siemplify.return_package(processed_alerts)\n\n\ndef pass_filters(\n    siemplify, whitelist_as_a_blacklist, alert, model_key, percentage_threshold\n):\n    # All alert filters should be checked here\n    if int(alert.percentage_threshold) < percentage_threshold:\n        siemplify.LOGGER.info(\n            f\"Alert with id: {alert.id} did not pass engine threshold.\"\n        )\n        return False\n\n    if not pass_whitelist_filter(siemplify, whitelist_as_a_blacklist, alert, model_key):\n        return False\n\n    return True\n\n\nif __name__ == \"__main__\":\n    # Connectors are run in iterations. The interval is configurable from the ConnectorsScreen UI.\n    is_test = not (len(sys.argv) < 2 or sys.argv[1] == \"True\")\n    main(is_test)\n",
    "documentationLink": "https://cloud.google.com/chronicle/docs/soar/marketplace-integrations/virustotal-v3#livehunt-notifications-connector",
    "deviceProductField": "Product Name",
    "eventNameField": "type",
    "connectorStatus": null,
    "isNew": false,
    "agentIdentifier": null
}